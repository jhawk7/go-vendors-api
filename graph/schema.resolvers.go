package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/jhawk7/go-vendors-api/graph/model"
	"github.com/jhawk7/go-vendors-api/internal/pkg/db"
	"github.com/sirupsen/logrus"
)

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input *model.NewVendor) (*model.Vendor, error) {
	dbVendor := new(db.Vendor)
	mVendor := new(model.Vendor)

	if reflect.DeepEqual(dbClient, db.DBClient{}) {
		getDBConn()
	}

	if mErr := mapObject(input, dbVendor); mErr != nil {
		errorHandler(mErr, false)
		return mVendor, mErr
	}

	if createErr := dbClient.CreateVendor(dbVendor); createErr != nil {
		errorHandler(createErr, false)
		return mVendor, createErr
	}

	if mErr := mapObject(dbVendor, mVendor); mErr != nil {
		errorHandler(mErr, false)
		return mVendor, mErr
	}

	return mVendor, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, input *model.UpdateVendor) (*model.Vendor, error) {
	mVendor := new(model.Vendor)
	dbUpdate := new(db.UpdateRequest)

	if reflect.DeepEqual(dbClient, db.DBClient{}) {
		getDBConn()
	}

	if mErr := mapObject(input, dbUpdate); mErr != nil {
		errorHandler(mErr, false)
		return mVendor, mErr
	}

	dbVendor, _, dbErr := dbClient.UpdateVendor(dbUpdate)
	if dbErr != nil {
		errorHandler(dbErr, false)
		return mVendor, dbErr
	}

	if mErr := mapObject(dbVendor, mVendor); mErr != nil {
		errorHandler(dbErr, false)
		return mVendor, dbErr
	}

	return mVendor, nil
}

// DeleteVendor is the resolver for the deleteVendor field.
func (r *mutationResolver) DeleteVendor(ctx context.Context, name *string) (*string, error) {
	if reflect.DeepEqual(dbClient, db.DBClient{}) {
		getDBConn()
	}

	dbClient.DeleteVendor(*name)
	message := fmt.Sprintf("vendor %v deleted", *name)
	return &message, nil
}

// GetActiveVendors is the resolver for the getActiveVendors field.
func (r *queryResolver) GetActiveVendors(ctx context.Context) ([]*model.Vendor, error) {
	var mVendors []*model.Vendor
	if reflect.DeepEqual(dbClient, db.DBClient{}) {
		getDBConn()
	}

	dbVendors, dbErr := dbClient.GetActiveVendors()
	if dbErr != nil {
		errorHandler(dbErr, false)
		return mVendors, dbErr
	}

	if mErr := mapObject(*dbVendors, &mVendors); mErr != nil {
		errorHandler(mErr, false)
		return mVendors, mErr
	}

	return mVendors, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var dbClient *db.DBClient

func getDBConn() {
	if client, err := db.InitDB(); err != nil {
		panic(fmt.Errorf("failed to connect to db; [error: %v]", err))
	} else {
		dbClient = client
	}
}
func errorHandler(err error, fatal bool) {
	if err != nil {
		logrus.Error(fmt.Errorf("error: %v", err))

		if fatal {
			panic(err)
		}
	}
}
func mapObject(oldObject interface{}, newObject interface{}) (mErr error) {
	bytes, bErr := json.Marshal(oldObject)
	if bErr != nil {
		mErr = bErr
		return
	}

	if jsonErr := json.Unmarshal(bytes, &newObject); jsonErr != nil {
		mErr = jsonErr
		return
	}

	return
}
